"Escape Hatches: Control systems outside React. useRef(initialValue): Persists values between renders without re-rendering. ref.current to access value. Manipulating the DOM with refs: const ref = useRef(null); <input ref={ref} />; ref.current.focus() useEffect(fn, [deps]): Synchronize with external systems after rendering. Cleanup function returns from fn. Example: useEffect(() => { connection.connect(); return () => connection.disconnect(); }, [roomId]); You Might Not Need An Effect: Avoid for data transformation or user events. Use for external systems only. Lifecycle of reactive effects: Effects start/stop synchronization. React linter checks Effect dependencies. useEffectEvent: Prevents re-running Effects for specific value changes. Removing Effect dependencies: Move code to prevent unnecessary dependencies. Change code to change dependency list. Reusing logic with custom Hooks: Share logic between components. <textarea>: multiline text input. Props: value (string, controlled, requires onChange), defaultValue (string, uncontrolled initial value), autoComplete, autoFocus, children (none, use defaultValue), cols (number, default width), disabled, form, maxLength, minLength, name, onChange (Event handler, required for controlled), onInput, onInvalid, onSelect, placeholder, readOnly, required, rows (number, default height), wrap. Controlled textarea: has value prop, requires onChange to update value. Uncontrolled: uses defaultValue. Caveats: no children, controlled/uncontrolled cannot change, controlled needs onChange. Troubleshooting: no update (missing onChange), caret jump (incorrect onChange), \"uncontrolled to controlled\" (value prop type issue, ensure string value). createRoot(domNode, options?): Creates a React root for a DOM element. Returns object with render and unmount methods. Options: onCaughtError, onUncaughtError, onRecoverableError, identifierPrefix. render(reactNode): Renders a React node. unmount(): Unmounts the root. Caveats: Server-rendered apps use hydrateRoot; one createRoot call per app usually. Renders a form input. Props: accept: string, alt: string, autoComplete: string, autoFocus: bool, capture: string, checked: bool (controlled), defaultChecked: bool (uncontrolled), defaultValue: string (uncontrolled), dirname: string, disabled: bool, form: string, formAction: string/func, formEnctype: string, formMethod: string, formNoValidate: string, formTarget: string, height: string, list: string, max: number, maxLength: number, min: number, minLength: number, multiple: bool, name: string, onChange: func (required for controlled), onInput: func, onInvalid: func, onSelect: func, pattern: string, placeholder: string, readOnly: bool, required: bool, size: number, src: string, step: number, type: string, value: string (controlled), width: string. Controlled inputs require value/checked and onChange. Uncontrolled use defaultValue/defaultChecked. Caveats: Checkboxes use checked/defaultChecked. String value prop makes text input controlled. Boolean checked prop makes checkbox/radio controlled. Cannot switch between controlled/uncontrolled. Controlled input needs synchronous onChange to update value. useState is a React Hook to add a state variable. const [state, setState] = useState(initialState). useState(initialState): initialState can be value or initializer function. Returns: [state, setState]. setState(nextState): updates state, nextState can be value or updater function(prevState => nextState). Caveats: call at top level of component. set function batches updates. In Strict Mode, initializer/updater runs twice (dev-only). Server React DOM APIs: renderToPipeableStream(tree, options): Node.js Stream. Renders React tree to pipeable Node.js stream. renderToReadableStream(tree, options): Readable Web Stream. Renders React tree to Readable Web Stream. renderToString(tree, options): string. Renders React tree to string (legacy, non-streaming). renderToStaticMarkup(tree, options): string. Renders non-interactive React tree to string (legacy, non-streaming). useRef(initialValue): Hook. Returns ref object {current: initialValue}. Access DOM nodes or mutable values. ref attribute: JSX. <div ref={myRef}>. Links DOM node to myRef.current. forwardRef(render): Function. Forwards ref to child component. render(props, ref) => ReactNode. useImperativeHandle(ref, createHandle, dependencies?): Hook. Customizes ref with forwardRef. createHandle() => object, ref value. Ref callback: ref={node => {...}}. Called with DOM node/null. Access child DOM: forwardRef in child. DOM manipulation caution: Avoid modifying React-managed DOM. flushSync(callback): Function. Sync state updates before DOM ops. Example: const inputRef = useRef(null); inputRef.current.focus(); Server Functions: `use server` directive. Called from Client Components; executes on server. Can be passed as props or imported. Works with Actions, Forms, `useActionState` (provides pending state, last response, progressive enhancement via permalink). renderToPipeableStream(reactNode, options?): Renders a React tree to a Node.js Stream. Returns {pipe, abort}. pipe(response): Outputs HTML to a Writable Node.js Stream. abort(): Aborts server rendering, renders rest on client. options: bootstrapScriptContent: Inline script content (string). bootstrapScripts: Array of script URLs (string[]). bootstrapModules: Array of module script URLs (string[]). identifierPrefix: Prefix for IDs generated by useId (string). namespaceURI: Root namespace URI (string). nonce: Nonce string for Content-Security-Policy. onAllReady: Callback when all content is rendered. onError: Callback for server errors (error: Error). onShellReady: Callback after initial shell is rendered. Call pipe() here to start streaming. onShellError: Callback if initial shell rendering fails (error: Error). progressiveChunkSize: Chunk size in bytes. Example: renderToPipeableStream(, { bootstrapScripts: ['/main.js'], onShellReady() { response.setHeader('content-type', 'text/html'); pipe(response); } }); Use Suspense for streaming content as it loads. Wrap parts of the UI to be loaded later in . createContext(defaultValue): Context object. Creates context. SomeContext.Provider: component, value prop. Provides context value. useContext(SomeContext): hook, returns context value. Reads context. SomeContext.Consumer: (legacy) component, children prop (function). Reads context value. useActionState: Hook to update state based on form action result. const [state, formAction, isPending] = useActionState(fn, initialState, permalink?); fn: (previousState, formData) => newState. initialState: initial state value. permalink: optional string, page URL for progressive enhancement. Returns: [state, formAction, isPending]. state: current state (initially initialState, then action's return value). formAction: action for form or button. isPending: boolean, true if action is pending. Example: const [state, formAction] = useActionState(increment, 0); <form>{state}<button formAction={formAction}>Increment</button></form> First argument to fn is previous state. Wrapped actions receive state as first arg, formData as second. memo(Component, arePropsEqual?) skips re-rendering when props are unchanged. Component: React component to memoize. arePropsEqual: (prevProps, newProps) => boolean, defaults to Object.is comparison. Returns memoized component. Re-renders on state or context changes. Use useMemo/useCallback to minimize prop changes. Shallow comparison of props. renderToString: Renders a React tree to an HTML string. const html = renderToString(reactNode, options?). Parameters: reactNode, options(optional identifierPrefix). Returns: HTML string. Limited Suspense support: renders fallback HTML. Not recommended for client code. Alternatives: renderToPipeableStream (Node.js), renderToReadableStream (Deno/edge runtime), prerenderToNodeStream, prerender. Example: app.use('/', (request, response) => { const html = renderToString(<App />); response.send(html); }); startTransition(action): Marks state updates as Transitions for non-blocking UI. action: () => void; Updates state via set functions. Async calls require wrapping set functions in additional startTransition. Example: startTransition(() => setTab(nextTab)); Returns: void. Caveats: No pending indicator (use useTransition). Requires access to set function. Updates are interrupted by other updates. Not for text inputs. map(callback): Array method. Transforms array to components. array.map(item => <Component key=item.id />); filter(callback): Array method. Filters array based on callback test. array.filter(item => item.condition); key prop: Required for list items from map(). Unique, stable identifier. <li key={item.id}>. Keys must be unique among siblings and stable across renders. Avoid index as key. Example: people.map(person => <li key={person.id}>{person.name}</li>); React Hooks: Built-in hooks for using React features. State Hooks: useState: Declares a state variable. const [state, setState] = useState(initialState); useReducer: Declares a state variable with reducer logic. const [state, dispatch] = useReducer(reducer, initialState); Context Hooks: useContext: Reads and subscribes to a context. const value = useContext(MyContext); Ref Hooks: useRef: Declares a ref. const ref = useRef(initialValue); useImperativeHandle: Customizes the ref exposed by a component. useImperativeHandle(ref, createHandle, [dependencies]); Effect Hooks: useEffect: Connects a component to an external system. useEffect(effect, [dependencies]); cleanup function can be returned. useLayoutEffect: Fires before the browser repaints. useLayoutEffect(effect, [dependencies]); useInsertionEffect: Fires before React makes changes to the DOM. useInsertionEffect(effect, [dependencies]); Performance Hooks: useMemo: Caches the result of a calculation. const value = useMemo(() => computeExpensiveValue(a, b), [a, b]); useCallback: Caches a function definition. const memoizedCallback = useCallback(() => { doSomething(a, b); }, [a, b]); useTransition: Marks a state transition as non-blocking. const [isPending, startTransition] = useTransition(); startTransition(() => {setState(newState)}); useDeferredValue: Defers updating a non-critical part of the UI. const deferredValue = useDeferredValue(value); Other Hooks: useDebugValue: Customizes the label for a custom Hook in React DevTools. useDebugValue(value, format); useId: Associates a unique ID with a component. const id = useId(); useSyncExternalStore: Subscribes to an external store. const snapshot = useSyncExternalStore(subscribe, getSnapshot); useActionState: Manages the state of actions. const [state, dispatch] = useActionState(fn, initialState); Custom Hooks: Define your own hooks as JavaScript functions. <option>: renders option in <select>. Props: disabled, label, value. React doesn't support selected; use defaultValue or value on <select>. useActionState(action, initialState, permalink?) Hook. Updates state based on form action result. action: form action function. initialState: initial state. permalink?: page URL for dynamic content. Returns: [state, formAction, isPending]. state: current state. formAction: action for form. isPending: pending transition. Caveat: action receives previous state as first arg. Components use props to communicate. Parent passes info to children. Props are like HTML attributes, but can be any JS value. Passing props: Add props to the JSX tag: <Avatar person={{ name: 'Lin' }} size={100} /> Reading props: Use destructuring: function Avatar({ person, size }) { ... } Default value: function Avatar({ size = 100 }) { ... } Only used if prop missing or undefined. Forwarding props: <Avatar {...props} /> Passes all props. Use sparingly. Children: Content nested inside a JSX tag is passed as the children prop. <Card><Avatar /></Card> Card receives children=<Avatar />. Props change over time but are immutable. Components receive new props on re-render. Can't change props directly, use state. Example: <Clock color={color} time={time} /> color and time are props. Event handlers: Run on specific interactions. Effects: Re-synchronize based on dependencies. useEffectEvent: Hook to extract non-reactive logic from Effects. Syntax: const onEvent = useEffectEvent(() => { ... }); Call onEvent() inside useEffect. Limitations: Only call from inside Effects. Do not pass to other components/Hooks. <script>: Adds a script to the document. Props: children (string, inline script), src (string, external script), async (boolean), crossOrigin (string), fetchPriority (string), integrity (string), noModule (boolean), nonce (string), referrer (string), type (string). Props: onError (function), onLoad (function). Special behavior: Can move to <head> and de-duplicate scripts with src and async={true}. Limitations: Ignores prop changes after rendering. May leave script in DOM after unmount. Component: Reusable UI element. React component is a JavaScript function with markup. Function names must start with a capital letter. export default function MyComponent() { return <div>Hello</div>; } Use <MyComponent /> to render. Do not nest component definitions. Parent components pass data to children via props. Class: style. Purpose: Add inline CSS stylesheets. Parameters: children(string, required): stylesheet content; precedence(string): style ranking; href(string): deduplicate styles; media(string): media query restriction; nonce(string): CSP nonce; title(string): alternative stylesheet name. Exceptions: React ignores prop changes after render; styles may remain in DOM after unmount. <link>: renders a link element. Props: rel(string, req'd), href(string, req'd), precedence(string, for stylesheets), media(string), title(string), disabled(bool), onError(func), onLoad(func), as(string), imageSrcSet(string), imageSizes(string), sizes(string), crossOrigin(string), referrerPolicy(string), fetchPriority(string), hrefLang(string), integrity(string), type(string). Stylesheets: React deduplicates, suspends rendering until load, order controlled by precedence. Exceptions: precedence omitted, onLoad/onError/disabled provided removes special behavior. ReactDOM APIs for web. createPortal: render children in different DOM. flushSync: force update DOM sync. Resource preloading: prefetchDNS, preconnect, preload, preloadModule, preinit, preinitModule for faster loading. Entry points: react-dom/client (client), react-dom/server (server). Removed: findDOMNode, hydrate(use hydrateRoot), render(use createRoot), unmountComponentAtNode(use root.unmount), renderToNodeStream, renderToStaticNodeStream. Component is base class for React components. Use function components instead. Class methods: constructor(props) initializes component, use super(props); this.state = {} for initial state. componentDidCatch(error, info) called after child error, error: Error, info: {componentStack: string}, no return. componentDidMount() called after mount, no params, no return. componentDidUpdate(prevProps, prevState, snapshot?) called after update, prevProps: object, prevState: object, snapshot?: any, no return. componentWillUnmount() called before unmount, no params, no return. forceUpdate(callback?) forces re-render, callback?: function, no return, skips shouldComponentUpdate. getSnapshotBeforeUpdate(prevProps, prevState) called before DOM update, prevProps: object, prevState: object, returns snapshot value for componentDidUpdate. render() returns ReactNode, required, pure function of props/state. setState(nextState, callback?) updates state, nextState: object|function(prevState, props) returns object, callback?: function, no return, enqueues update. shouldComponentUpdate(nextProps, nextState, nextContext) determines if re-render can be skipped, nextProps: object, nextState: object, nextContext?: object, returns boolean, default true. Static properties: contextType: Context, specifies context to read this.context. defaultProps: object, default props. getDerivedStateFromError(error) updates state on error, error: Error, returns state object. getDerivedStateFromProps(props, state) updates state from props, props: object, state: object, returns state object or null. Properties: context: Context, component context if contextType is defined. props: object, component props. state: object, component state. Usage: extend Component class, define render(). State is this.state, update with this.setState(). Lifecycle methods for side effects and updates. act: Test helper for applying React updates before assertions. await act(async actFn). Wrap component rendering/updates in act(). Parameters: async actFn: async function wrapping renders/interactions. Example: it ('renders with button disabled', async () => { await act(async () => { root.render(<TestComponent />) }); expect(container.querySelector('button')).toBeDisabled(); }); Error: \"The current testing environment is not configured to support act\" requires setting global.IS_REACT_ACT_ENVIRONMENT=true. Sharing State Between Components: Lift state to common parent. Accordion: Parent component rendering Panels. Panel: Displays content based on isActive. Lifting State: 1. Remove state from child components. function Panel({ title, children, isActive }) 2. Pass hardcoded data from parent. Accordion passes isActive prop. 3. Add state to parent, pass down with handlers. const [activeIndex, setActiveIndex] = useState(0); Controlled vs Uncontrolled: Uncontrolled has local state, controlled is driven by props. Single Source of Truth: Each piece of state has a specific owner component. Synced Inputs Example: Editing one input updates the other. useImperativeHandle(ref, createHandle, dependencies): customizes ref handle. ref: received ref. createHandle: returns ref handle. dependencies: reactive values. returns undefined. Avoid overuse; prefer props for non-imperative behaviors. cloneElement: Creates a new React element using another element as a starting point. const clonedElement = cloneElement(element, props, ...children); Parameters: element: React element to clone. props: Props to override (or null). children: New children (optional). Returns: New React element. Caveats: Cloning does not modify original element. Pass static children as multiple args, dynamic children as array. Usage: Overriding props: cloneElement(<Row title=\"Cabbage\" />, { isHighlighted: true }). Alternatives: Render props, Context, Custom Hooks. Reducers consolidate state logic. useReducer(reducer, initialState) Hook manages state. Returns [state, dispatch]. reducer(state, action) Function. Takes state, action, returns nextState. Actions describe user events. useReducer vs useState: useReducer for complex state logic, better debugging and testing. cache(fn): caches function results. fn: function to cache. returns cached fn. Server Components only. Invalidates cache per request. Use same memoized function across components for cache sharing. Use useMemo for client components, memo for preventing re-renders based on unchanged props. useEffect(setup, dependencies?): Hook to synchronize component with external system. setup: Function with Effect's logic. Returns optional cleanup function. cleanup runs: before unmount, before re-render with dependency change. dependencies: Array of reactive values (props, state, component variables/functions). useEffect returns undefined. Caveats: Call at top level. Not for data flow. StrictMode runs extra setup+cleanup in dev. Alternatives: Framework data fetching, client-side cache. Dependencies: Must declare all reactive values. To update state based on previous state, use updater function setCount(c => c + 1). Avoid object/function dependencies. useEffectEvent for non-reactive code. Server/Client: Use `didMount` state with useEffect for client-only logic. Troubleshooting: StrictMode runs setup twice. Infinite cycle: Effect updates state, state changes dependencies. Cleanup should mirror setup. Replace with useLayoutEffect to block browser paint. `use(resource)`: Reads resource value (Promise, context). Integrates with Suspense, error boundaries. Returns resolved value. Must be called in Component/Hook. For Server Components, prefer `async/await`. Promises from Server Components are stable across renders. Handles rejected Promises via error boundaries or `Promise.catch`. Exceptions: Calling outside Component/Hook or in `try-catch`. renderToStaticMarkup(reactNode, options?) renders non-interactive React tree to HTML string. Params: reactNode, options?:{identifierPrefix?:string}. Returns: HTML string. Caveats: no hydrate, limited Suspense, server-only. React preserves state based on component position in UI tree. Same component at same position preserves state. Different component types at same position reset state. Keys control component identity. key prop forces state reset when key changes. Resetting state with keys useful for forms and independent components. Example: Scoreboard with keys for separate counters. Nested component definitions cause state reset on re-renders. Avoid nested component functions. State reset with different keys: . Server Functions: async functions executed on the server called from Client Components. Defined with \"use server\" directive in Server Components or separate files. Framework creates reference passed to client. Client call sends request to server to execute function, returns result. Usage: Server Components define Server Functions, import in Client Components. Server Actions: Server Functions used in action prop or called inside action. Server Functions in Forms: use with form action for submission. Server Functions with useActionState: access pending state and response. Progressive enhancement with useActionState: redirect if form submitted before hydration. React State: Manage UI updates declaratively. Identify component visual states, triggers for state changes (user/computer input). Use `useState` to represent state in memory. Minimize state variables, avoid paradoxes. Connect event handlers to set state. Example: `useState('')`, `useState(null)`, `useState('typing')`. : Component. Props: fallback, children. Displays fallback until children load. fallback: Prop. Params: React node. Fallback UI. children: Prop. Params: React node. Content to render. useDeferredValue(value): Function. Params: value. Returns: deferredValue. Defers updates for non-urgent UI. startTransition(callback): Function. Params: callback. Returns: void. Marks update as non-urgent, prevents hiding content. useTransition(): Function. Returns: [isPending, startTransition]. Gets transition status. key: Prop. Resets Suspense on navigation. Components and Hooks must be pure: Pure: Idempotent (same input = same output), no side effects in render, doesn't mutate non-local values. Why purity matters: React optimizes updates based on purity. React Phases: Rendering (calculates UI), Effects (runs after render). Render Code: Top-level code in component definition. Event handlers/Effects don't run in render. Idempotency: Components must always return the same output with same inputs (props, state, context). Side Effects: Run outside render (event handlers, useEffect). Mutation: Local mutation okay. Avoid mutating props/state directly. Props and State: Immutable snapshots. Use setter from useState. Hook Arguments/Returns: Treat as immutable. JSX: Don't mutate values after use in JSX. Fragment: <Fragment> or <></> syntax groups elements without wrapper node. Usage: group multiple elements where single element expected. No DOM effect. <></> shorthand for <Fragment></Fragment>. Props: optional key (only with <Fragment> syntax). Use cases: return multiple elements, assign to variable, group with text, render list (requires key, use <Fragment key>). No state reset on single level Fragment change. useFormStatus Hook: Returns status of last form submission. Requires component inside a . Returns: pending: boolean, true if form is submitting. data: FormData object of form data, null if no submission. method: string, 'get' or 'post' of form. action: function, action passed to form. Null if URI action or no action prop. Caveats: Must be called inside a . Only tracks parent . flushSync(callback): Forces React to flush updates and update the DOM synchronously. callback: function. Returns undefined. Caveats: Can hurt performance. Forces Suspense fallbacks. May run Effects. 'use server': Marks server-side functions callable from client code. async function myFunc(args) { 'use server'; }. Can be module level to apply to all exports. Arguments and return values must be serializable. Used for mutations, not data fetching. Arguments treated as untrusted input. Call Server Functions in a Transition. React provides FormData as first argument in forms. Example: <form action={requestUsername}><input type=\"text\" name=\"username\" /><button>Request</button></form> Use useActionState to handle return values in forms. Server Functions called outside form must be in Transition. State Updates: set state to queue a re-render. React batches updates for efficiency. setNumber(number + 1) within the same event handler uses the same `number` value. To update based on the previous state in the same event, use an updater function: setNumber(n => n + 1). React processes queued updater functions (n => n + 1) during the next render. Replace updates: setNumber(5) replaces existing updates in the queue. const [number, setNumber] = useState(0); setNumber(n => n + 1); //updater function. setNumber(5); //replaces the update. useInsertionEffect(setup, dependencies): Inserts DOM elements before layout effects. For CSS-in-JS libraries. setup: Effect function (returns cleanup). dependencies: Reactive values. Returns undefined. Caveats: Client-side only, no state updates, refs not yet attached, DOM update timing unreliable. useDebugValue(value, format?) Hook. Adds label to custom Hook in React DevTools. value: displayed value. format?: formatting function. Returns: void. Updating Arrays in State: update arrays immutably in React. Avoid mutating methods: push, pop, shift, unshift, splice, reverse, sort, array[index]=value. Prefer non-mutating: concat, [...array], filter, slice, map, copy array before reverse/sort. filter(callback): returns new filtered array. map(callback): returns new transformed array. [...array, newItem]: adds item to array. slice(): copies array/part. Immer library: simplifies immutable updates using draft objects. Updating objects in arrays: copy objects during update. Use map to update objects in arrays. <title>: Sets document title. Rendered <title> tag placed in document <head>. Props: children: Text for the document title. Special Rendering: <title> is placed in <head> regardless of render location, unless inside <svg> or has itemProp. Pitfall: Render only one <title> at a time to avoid undefined browser behavior. Example: <title>My Site: Contact Us</title> Use string interpolation for variables: <title>{`Results page ${pageNumber}`}</title> <meta>: Adds metadata to the document. Props: name (string), httpEquiv (string), charset (string), itemProp (string), content (string). Special behavior: Element placed in <head> unless itemProp is specified. preinitModule(href, options): Eagerly fetch and evaluate ESM module. Parameters: href: module URL string, options: {as: 'script', crossOrigin: CORS string, integrity: string, nonce: string}. Usage: hints browser to download/execute module. Caveats: multiple calls same href=single effect; SSR/Server Components=effect in rendering context only. useEffect dependencies: Must include all reactive values read by the effect. Removing dependencies: Move non-reactive values outside component or inside useEffect. Splitting Effects: Separate unrelated tasks into multiple useEffect calls. Reading state without reacting: Use Effect Events. Avoid object/function dependencies: Extract primitive values. Suppressing linter is dangerous. Server Components render ahead of time on the server. Async components allow await in render. Can run at build time or per request. Client Components add interactivity via \"use client\". No \"use server\" directive for Server Components. Avoid unnecessary useEffect: Data transformation during rendering, event handling in event handlers. Use useMemo for expensive calculations. Reset state with keys. Adjust state during rendering, not in Effects. Share logic between handlers. Fetching data: Add cleanup to avoid race conditions. UseSyncExternalStore for external stores. React DOM Components supports built-in HTML and SVG components. Common components: div, span, etc. Form components: input, select, textarea. Resource/Metadata components: link, meta, script, style, title. All HTML components: aside, audio, b, base, bdi, bdo, blockquote, body, br, button, canvas, caption, cite, code, col, colgroup, data, datalist, dd, del, details, dfn, dialog, div, dl, dt, em, embed, fieldset, figcaption, figure, footer, form, h1-h6, head, header, hgroup, hr, html, i, iframe, img, input, ins, kbd, label, legend, li, link, main, map, mark, menu, meta, meter, nav, noscript, object, ol, optgroup, option, output, p, picture, pre, progress, q, rp, rt, ruby, s, samp, script, section, select, slot, small, source, span, strong, style, sub, summary, sup, table, tbody, td, template, textarea, tfoot, th, thead, time, title, tr, track, u, ul, var, video, wbr. Props use camelCase. Custom HTML elements use class, for. All SVG components: a, animate, animateMotion, animateTransform, circle, clipPath, defs, desc, discard, ellipse, feBlend, feColorMatrix, feComponentTransfer, feComposite, feConvolveMatrix, feDiffuseLighting, feDisplacementMap, feDistantLight, feDropShadow, feFlood, feFuncA, feFuncB, feFuncG, feFuncR, feGaussianBlur, feImage, feMerge, feMergeNode, feMorphology, feOffset, fePointLight, feSpecularLighting, feSpotLight, feTile, feTurbulence, filter, foreignObject, g, hatch, hatchpath, image, line, linearGradient, marker, mask, metadata, mpath, path, pattern, polygon, polyline, radialGradient, rect, script, set, stop, style, svg, switch, symbol, text, textPath, title, tspan, use, view. SVG attributes: camelCase, namespaced attributes without colon e.g. xlinkActuate. Static React DOM APIs: prerender (Web Streams), prerenderToNodeStream (Node.js Streams). Limited functionality; mainly for frameworks. React Developer Tools: Inspect React components, edit props/state, identify performance issues. Install browser extension (Chrome, Firefox, Edge) or use npm (react-devtools). Use Components and Profiler panels. For Safari: npm install -g react-devtools; react-devtools; add <script src=\"http://localhost:8097\"></script> to <head>. For React Native: npm install -g react-devtools; react-devtools. Editor recommendations: VS Code, WebStorm, Sublime Text, Vim. Features: ESLint linting, Prettier formatting, format-on-save. ESLint-config-prettier prevents conflicts between ESLint and Prettier formatting rules. Installation: Try React: online sandboxes. Locally: download HTML. New project. Add to existing project. Tools: Editor setup, React Developer Tools. React models UI as a tree. Render tree: UI tree of rendered components, nodes represent components. Module dependency tree: nodes represent modules, branches represent import statements. Used by bundlers to determine modules to include. `prerender(reactNode, options?)`: Renders React tree to static HTML string/stream. `reactNode`: React node (full document). `options`: `bootstrapScripts`, `bootstrapScriptContent`, `bootstrapModules`, `identifierPrefix`, `namespaceURI`, `onError`, `progressiveChunkSize`, `signal`. Returns Promise resolving to `{prelude}` (HTML stream/string). Waits for all data to load; suitable for SSG. Client-side hydration needed (`hydrateRoot`). Uses Web Streams; Node.js uses `prerenderToNodeStream`. Exceptions: Stream may not start until full render; no streaming support. Common props for built-in components (e.g. <div>): children: React node, content inside the component. dangerouslySetInnerHTML: { __html: string }, raw HTML, use with caution, potential XSS vulnerability. ref: Ref object or callback function, DOM element. suppressContentEditableWarning: boolean, suppresses contentEditable warning. suppressHydrationWarning: boolean, suppresses hydration mismatches. style: CSS styles object, camelCase names. className: CSS class name. accessKey: string, keyboard shortcut. aria-*: ARIA attributes. autoCapitalize: string. contentEditable: boolean, editable element. data-*: Data attributes. dir: string, text direction. draggable: boolean. enterKeyHint: string. htmlFor: string, label association. hidden: boolean. id: string, unique identifier. is: string, custom element. inputMode: string, keyboard type. itemProp: string, structured data. lang: string, language. onAnimationEnd: AnimationEvent handler. onAnimationIteration: AnimationEvent handler. onAnimationStart: AnimationEvent handler. onAuxClick: MouseEvent handler. onBeforeInput: InputEvent handler. onBlur: FocusEvent handler. onClick: MouseEvent handler. onCompositionStart: CompositionEvent handler. onCompositionEnd: CompositionEvent handler. onCompositionUpdate: CompositionEvent handler. onContextMenu: MouseEvent handler. onCopy: ClipboardEvent handler. onCut: ClipboardEvent handler. onDoubleClick: MouseEvent handler. onDrag: DragEvent handler. onDragEnd: DragEvent handler. onDragEnter: DragEvent handler. onDragOver: DragEvent handler, call e.preventDefault() to allow dropping. onDragStart: DragEvent handler. onDrop: DragEvent handler. onFocus: FocusEvent handler. onGotPointerCapture: PointerEvent handler. onKeyDown: KeyboardEvent handler. onKeyPress: KeyboardEvent handler, deprecated. onKeyUp: KeyboardEvent handler. onLostPointerCapture: PointerEvent handler. onMouseDown: MouseEvent handler. onMouseEnter: MouseEvent handler. onMouseLeave: MouseEvent handler. onMouseMove: MouseEvent handler. onMouseOut: MouseEvent handler. onMouseUp: MouseEvent handler. onPointerCancel: PointerEvent handler. onPointerDown: PointerEvent handler. onPointerEnter: PointerEvent handler. onPointerLeave: PointerEvent handler. onPointerMove: PointerEvent handler. onPointerOut: PointerEvent handler. onPointerUp: PointerEvent handler. onPaste: ClipboardEvent handler. onScroll: Event handler, does not bubble. onSelect: Event handler. onTouchCancel: TouchEvent handler. onTouchEnd: TouchEvent handler. onTouchMove: TouchEvent handler. onTouchStart: TouchEvent handler. onTransitionEnd: TransitionEvent handler. onWheel: WheelEvent handler. role: string, accessibility role. slot: string, shadow DOM slot. spellCheck: boolean or null. tabIndex: number. title: string, tooltip. translate: string. Custom attributes are also supported. Events for <form>: onReset, onSubmit. Events for <dialog>: onCancel, onClose. Events for <details>: onToggle. Events for images/media: onLoad, onError, onAbort, onCanPlay, onCanPlayThrough, onDurationChange, onEmptied, onEncrypted, onEnded, onLoadedData, onLoadedMetadata, onLoadStart, onPause, onPlay, onPlaying, onProgress, onRateChange, onResize, onSeeked, onSeeking, onStalled, onSuspend, onTimeUpdate, onVolumeChange, onWaiting. Caveats: Cannot use children and dangerouslySetInnerHTML together. Some events bubble in React but not in the browser. ref callback: ref={(node) => {}}: Called when attached/detached. React event object: Synthetic event, e.preventDefault(), e.stopPropagation(), e.nativeEvent. AnimationEvent: animationName, elapsedTime, pseudoElement. ClipboardEvent: clipboardData. CompositionEvent: data. DragEvent: dataTransfer, MouseEvent props, UIEvent props. FocusEvent: relatedTarget, UIEvent props. InputEvent: data. KeyboardEvent: altKey, charCode, code, ctrlKey, key, keyCode, locale, metaKey, location, repeat, shiftKey, which, UIEvent props. MouseEvent: altKey, button, buttons, ctrlKey, clientX, clientY, metaKey, movementX, movementY, pageX, pageY, relatedTarget, screenX, screenY, shiftKey, UIEvent props. PointerEvent: height, isPrimary, pointerId, pointerType, pressure, tangentialPressure, tiltX, tiltY, twist, width, MouseEvent props, UIEvent props. TouchEvent: altKey, ctrlKey, changedTouches, metaKey, shiftKey, touches, targetTouches, UIEvent props. TransitionEvent: elapsedTime, propertyName, pseudoElement. UIEvent: detail, view. WheelEvent: deltaMode, deltaX, deltaY, deltaZ, MouseEvent props, UIEvent props. State as Snapshot: State behaves as snapshot. setState triggers re-render, not immediate update. Event handlers capture state at render time. Multiple setState in same event handler batch updates for next render. Access latest state with state updater function. React APIs: createContext, useContext, forwardRef, useRef, lazy, memo, useMemo, useCallback, startTransition, useTransition, act, use. React Reference Overview. Sections: React Programmatic(Hooks, Components, APIs, Directives), React DOM(Hooks, Components, APIs, Client/Server APIs), Rules of React(Purity, React calls, Hooks rules), Legacy APIs(not recommended). State Structure Principles: Group related state, avoid contradictions, avoid redundant state, avoid duplication, avoid deep nesting. Guides for structuring state to simplify updates and reduce bugs."